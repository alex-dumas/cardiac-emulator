<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>The CARDIAC Emulator Documentation</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">The <span class="Larger">CARDIAC</span> Emulator Documentation</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.How_.The_.C.A.R.D.I.A.C_.Emulator_.Works%29" class="tocviewlink" data-pltdoc="x">How The <span class="Larger">CARDIAC</span> Emulator Works</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.The_.C.A.R.D.I.A.C_.Assembly_.Language_.Interface%29" class="tocviewlink" data-pltdoc="x">The <span class="Larger">CARDIAC</span> Assembly Language Interface</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.The_.C.A.R.D.I.A.C_.Emulator_.Documentation%29" class="tocsubseclink" data-pltdoc="x">The <span class="Larger">CARDIAC</span> Emulator Documentation</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.How_.The_.C.A.R.D.I.A.C_.Emulator_.Works%29" class="tocsubseclink" data-pltdoc="x">How The <span class="Larger">CARDIAC</span> Emulator Works</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Who_is_this_.Document_.For_%29" class="tocsubseclink" data-pltdoc="x">Who is this Document For?</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.What_.Goes_on_.Inside___%29" class="tocsubseclink" data-pltdoc="x">What Goes on Inside...</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._.Binary_vs__.Decimal_%29" class="tocsubseclink" data-pltdoc="x">Binary vs. Decimal?</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.The_.C.A.R.D.I.A.C_.Assembly_.Language_.Interface%29" class="tocsubseclink" data-pltdoc="x">The <span class="Larger">CARDIAC</span> Assembly Language Interface</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.The_.Assembly_.Language%29" class="tocsubseclink" data-pltdoc="x">The Assembly Language</a></td></tr><tr><td><span class="tocsublinknumber">2.1.1<tt>&nbsp;</tt></span><a href="#%28part._.The_.Direct_.Addressing_.Mode%29" class="tocsubseclink" data-pltdoc="x">The Direct Addressing Mode</a></td></tr><tr><td><span class="tocsublinknumber">2.1.2<tt>&nbsp;</tt></span><a href="#%28part._.The_.Indirect_.Addressing_.Mode%29" class="tocsubseclink" data-pltdoc="x">The Indirect Addressing Mode</a></td></tr><tr><td><span class="tocsublinknumber">2.1.3<tt>&nbsp;</tt></span><a href="#%28part._.The_.Literal_.Mode%29" class="tocsubseclink" data-pltdoc="x">The Literal Mode</a></td></tr><tr><td><span class="tocsublinknumber">2.1.4<tt>&nbsp;</tt></span><a href="#%28part._.The_.Commands%29" class="tocsubseclink" data-pltdoc="x">The Commands</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._.Without_the_.Visualizer%29" class="tocsubseclink" data-pltdoc="x">Without the Visualizer</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#%28part._.With_the_.Visualizer%29" class="tocsubseclink" data-pltdoc="x">With the Visualizer</a></td></tr><tr><td><span class="tocsublinknumber">2.3.1<tt>&nbsp;</tt></span><a href="#%28part._.What_is_the_.Visualizer_%29" class="tocsubseclink" data-pltdoc="x">What is the Visualizer?</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">6.1.1</span></div><h2><a name="(part._.The_.C.A.R.D.I.A.C_.Emulator_.Documentation)"></a>The <span class="Larger">CARDIAC</span> Emulator Documentation</h2><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.How_.The_.C.A.R.D.I.A.C_.Emulator_.Works%29" class="toptoclink" data-pltdoc="x">1<span class="hspace">&nbsp;</span>How The <span class="Larger">CARDIAC</span> Emulator Works</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Who_is_this_.Document_.For_%29" class="toclink" data-pltdoc="x">1.1<span class="hspace">&nbsp;</span>Who is this Document For?</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.What_.Goes_on_.Inside___%29" class="toclink" data-pltdoc="x">1.2<span class="hspace">&nbsp;</span>What Goes on Inside...</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Binary_vs__.Decimal_%29" class="toclink" data-pltdoc="x">1.3<span class="hspace">&nbsp;</span>Binary vs. Decimal?</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.The_.C.A.R.D.I.A.C_.Assembly_.Language_.Interface%29" class="toptoclink" data-pltdoc="x">2<span class="hspace">&nbsp;</span>The <span class="Larger">CARDIAC</span> Assembly Language Interface</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.The_.Assembly_.Language%29" class="toclink" data-pltdoc="x">2.1<span class="hspace">&nbsp;</span>The Assembly Language</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.The_.Direct_.Addressing_.Mode%29" class="toclink" data-pltdoc="x">2.1.1<span class="hspace">&nbsp;</span>The Direct Addressing Mode</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.The_.Indirect_.Addressing_.Mode%29" class="toclink" data-pltdoc="x">2.1.2<span class="hspace">&nbsp;</span>The Indirect Addressing Mode</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.The_.Literal_.Mode%29" class="toclink" data-pltdoc="x">2.1.3<span class="hspace">&nbsp;</span>The Literal Mode</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.The_.Commands%29" class="toclink" data-pltdoc="x">2.1.4<span class="hspace">&nbsp;</span>The Commands</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Without_the_.Visualizer%29" class="toclink" data-pltdoc="x">2.2<span class="hspace">&nbsp;</span>Without the Visualizer</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.With_the_.Visualizer%29" class="toclink" data-pltdoc="x">2.3<span class="hspace">&nbsp;</span>With the Visualizer</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.What_is_the_.Visualizer_%29" class="toclink" data-pltdoc="x">2.3.1<span class="hspace">&nbsp;</span>What is the Visualizer?</a></p></td></tr></table><h3>1<tt>&nbsp;</tt><a name="(part._.How_.The_.C.A.R.D.I.A.C_.Emulator_.Works)"></a>How The <span class="Larger">CARDIAC</span> Emulator Works</h3><p>The CARIDAC Emulator is useful to illustrate how computation works in a real life computor, without going into the rigamarole of binary and hex, or the many layers of complicated memory and operating system, but instead just using this simple and abstract environment to teach people about computors.</p><h4>1.1<tt>&nbsp;</tt><a name="(part._.Who_is_this_.Document_.For_)"></a>Who is this Document For?</h4><p><div class="SIntrapara">This chapter of this document is mainly targeted at would-be contributors or teachers looking to use this in their lessons. Furthur chapters will be documentation and description for how to program this machene, while this chapter will deatail how it works and how to use it in an educational environment. It is helpful if the teacher has some programming experiance, but that is obvous anyway since they are teaching a programming/computor science class. It will also help if the students are somewhat farmiliar with a dialect of lisp, javascript, lua, or ruby.
</div><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Students may read this too. This document is just more focused on the questions the teacher may have while teaching using this equitment.</p></blockquote></blockquote></blockquote></div></p><h4>1.2<tt>&nbsp;</tt><a name="(part._.What_.Goes_on_.Inside___)"></a>What Goes on Inside...</h4><p><div class="SIntrapara">As you may have already guessed, the <span style="font-weight: bold">CARDIAC</span> Emulator is written in a dialect of scheme, known as Racket.
It is fully cross-platform, and espesially designed to be simple and fairly easy to use. It may require a little bit of knowledge of scheme to use the more advanced tools, but there is an editor that we are working on to curcumvent the need to use string variables for your assembly in racket and launch the visualizer from the REPL.
The memory map is represented by a list of 100 memory locations, each containing up to three digits of value. Each memory loaction number has some metadata attached to it, indicating weather it is code or data, so that the bootstrapper knows what to run and what to use as data.
Empty memory map locations are represented by -1, becouse CARIDAC does not support negative numbers.
There are 10 instructions for the <span style="font-weight: bold">CARDIAC</span>, but the non-single-digit instructions do not take arguments, therby mitigating the possible problem of having too little space to represent numbers.
</div><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>If you wish to participate in the development of this project, check out the source code, beocuse this is all I will say about implementation details here.</p></blockquote></blockquote></blockquote></div></p><h4>1.3<tt>&nbsp;</tt><a name="(part._.Binary_vs__.Decimal_)"></a>Binary vs. Decimal?</h4><p>If you want to teach how computors work to people unfarmilliar with that topic previously, it will be long, hard, and tedious to make them fluent enough in binary for it to be helpful. Especially since assembly language uses hex or decimal for numbers, and there are many binary to hex or binary to decimal or hex to binary or hex to decimal converters out there already, without doing it by hand. This is why we chose to use decimal for the <span style="font-weight: bold">CARDIAC</span> instead.</p><h3>2<tt>&nbsp;</tt><a name="(part._.The_.C.A.R.D.I.A.C_.Assembly_.Language_.Interface)"></a>The <span class="Larger">CARDIAC</span> Assembly Language Interface</h3><p>This document details how to use the assembly language interface functions that the <span style="font-weight: bold">CARDIAC Emulator</span> supplies.</p><h4>2.1<tt>&nbsp;</tt><a name="(part._.The_.Assembly_.Language)"></a>The Assembly Language</h4><p><div class="SIntrapara">Each command has three modes:
</div><div class="SIntrapara"><ul><li><p>Direct addressing Mode</p></li><li><p>Indirect addressing Mode</p></li><li><p>Literal Mode</p></li></ul></div></p><h5>2.1.1<tt>&nbsp;</tt><a name="(part._.The_.Direct_.Addressing_.Mode)"></a>The Direct Addressing Mode</h5><p><div class="SIntrapara">This addressing mode is the default mode that all assembly language commands are executed in. In this mode, all memory locations refered to are the memory locations used in the command arguments. This mode acts exactly how the command is described. This is also the simplest mode.
This is how you use a direct addressed command:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">add 7</span></p></td></tr></table></div><div class="SIntrapara">In this case, it adds what is from memory location seven to the accumulator. To switch back to normal mode after using other modes, such as indirect or literal modes, use the </div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">nom</span></p></td></tr></table></div><div class="SIntrapara"> code.</div></p><h5>2.1.2<tt>&nbsp;</tt><a name="(part._.The_.Indirect_.Addressing_.Mode)"></a>The Indirect Addressing Mode</h5><p><div class="SIntrapara">This is the most useful, yet most complicated of the addressing modes. In this addressing mode, instead of directly using the address given to it, it insted uses the number from the address given as the argument, therefor allowing a sort of variably addressed command. This is useful for loops.
Here is an example:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">idi</span></p></td></tr><tr><td><p><span class="stt">add 7</span></p></td></tr><tr><td><p><span class="stt">nom</span></p></td></tr></table></div><div class="SIntrapara">In this case, it gets the number in memory location 7, lets say 88, and uses <span style="font-weight: bold">that</span> as the argument. So in this case, it is equivalant to:</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">add 88</span></p></td></tr></table></div><div class="SIntrapara">But that&rsquo;s not all that indirect addressing mode can do. If you need to referance the program counter or accumulator, which are not accesable in memory, you can use these labels, instead of numbers, after the # symbol:</div></p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span style="font-weight: bold">Label</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-weight: bold">Meaning</span></p></td></tr><tr><td><p>ACC</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>The contents of the accumulator</p></td></tr><tr><td><p>PC</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>The contents of the program counter</p></td></tr></table></p><h5>2.1.3<tt>&nbsp;</tt><a name="(part._.The_.Literal_.Mode)"></a>The Literal Mode</h5><p><div class="SIntrapara">In this mode, you can use literal numbers instead of memory addresses for certain opcodes. For example:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">lit</span></p></td></tr><tr><td><p><span class="stt">add 88</span></p></td></tr><tr><td><p><span class="stt">nom</span></p></td></tr></table></div><div class="SIntrapara">There is no real equivilant in normal assembly for this. In this case, it adds the number 88 to the accumulator.</div></p><h5>2.1.4<tt>&nbsp;</tt><a name="(part._.The_.Commands)"></a>The Commands</h5><p><div class="SIntrapara">The assembly language commands that you can use are as follows:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span style="font-weight: bold">Command</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-weight: bold">Action</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-weight: bold">Opcode</span></p></td></tr><tr><td><p>INP</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>INPut from input slot</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>1</p></td></tr><tr><td><p>CLA</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>CLear and input from memory to Accumulator</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>2</p></td></tr><tr><td><p>ADD</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>ADD from memory to accumulator</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>3</p></td></tr><tr><td><p>TAC</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>Test ACcumulator and jump to specified memory address if negative.</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>4</p></td></tr><tr><td><p>SFT</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>ShiFT Accumulator by specified bits</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>5</p></td></tr><tr><td><p>OUT</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>OUTput memory location to output slot</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>6</p></td></tr><tr><td><p>STO</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>STOre accumulator in memory</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>7</p></td></tr><tr><td><p>SUB</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>SUBtract memory from accumulator</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>8</p></td></tr><tr><td><p>JMP</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>JuMP to memory location</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>9</p></td></tr><tr><td><p>HRS</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>Halt and reset</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>10</p></td></tr></table></div><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Notice that the HRS instruction has a two digit opcode, therefor leaving only one digit for the argument. Luckely, it takes no arguments.</p></blockquote></blockquote></blockquote></div></p><h4>2.2<tt>&nbsp;</tt><a name="(part._.Without_the_.Visualizer)"></a>Without the Visualizer</h4><p>To run assembly language without the memory visualizer, using the Racket REPL, enter:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">(run-cardiac-assembly</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">&lt;start-mem&gt;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">&lt;code&gt;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">[&lt;input&gt; 0]</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">[&lt;output&gt; 0]</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">[&lt;acc&gt; 0]</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">[&lt;starting-memory-map&gt;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(create-memory-map start-mem)]</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">#:listener [&lt;mem-change-callback&gt; (lambda (mem) (void))])</span></p></td></tr></table></p><p>To construct assembly language programs, you need to use this command:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">(string-join '(</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"&lt;your line of code here 1&gt;"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"&lt;your line of code here 2&gt;"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"&lt;your line of code here 3&gt;"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"&lt;your line of code here n&gt;"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">) "\n")</span></p></td></tr></table></p><h4>2.3<tt>&nbsp;</tt><a name="(part._.With_the_.Visualizer)"></a>With the Visualizer</h4><p>To run code with the memory Visualizer, everything is the same, exept that you use a different funciton:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">(run-assembly &lt;start-mem&gt; &lt;code&gt; [&lt;input&gt; 0] [&lt;output&gt; 0] [&lt;acc&gt; 0])</span></p></td></tr></table></p><h5>2.3.1<tt>&nbsp;</tt><a name="(part._.What_is_the_.Visualizer_)"></a>What is the Visualizer?</h5><p>The Visualizer is a source code disassembler, crossed with a memory map light matrix. In layman&rsquo;s terms, it displays the contents of the memory of the <span style="font-weight: bold">CARDIAC</span> in a grid of color coded squares, with the disassembly of that memory address on top. It is very helpful for visualizing the memory of the <span style="font-weight: bold">CARDIAC</span> and the execution flow.
Here is a screenshot:
<img src="visualizer.png" alt="" width="564" height="532"/></p></div></div><div id="contextindicator">&nbsp;</div></body></html>